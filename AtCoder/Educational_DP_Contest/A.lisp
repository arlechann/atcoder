(eval-when (:compile-toplevel)
  #-swank (proclaim '(optimize (speed 3) (debug 0) (safety 0))))

(defparameter inf 2000000000)

(defun read-integer (&optional (in *standard-input*))
  (declare (inline read-byte))
  (labels ((number-char-p (b)
             (<= #.(char-code #\0) b #.(char-code #\9)))
           (minus-char-p (b)
             (= b #.(char-code #\-)))
           (to-number (b)
             (- b #.(char-code #\0))))
    (declare (inline number-char-p minus-char-p to-number))
    (macrolet ((%read-byte ()
                 '(the (unsigned-byte 8)
                       #+swank (char-code (read-char in nil #\Nul))
                       #-swank (read-byte in nil 0))))
      (let* ((minus-p nil)
             (x (loop for b = (%read-byte)
                      if (number-char-p b)
                        return (to-number b)
                        end
                      if (minus-char-p b)
                        do (setf minus-p t))))
        (declare (boolean minus-p) (fixnum x))
        (the fixnum (loop for b = (%read-byte)
                          and y = x then (+ (* y 10) (to-number b))
                          unless (number-char-p b)
                            return (funcall (if minus-p #'- #'+) y)))))))

(defun split (x str &optional (acc nil))
  (let ((pos (search x str))
        (size (length x)))
    (if pos
        (split x (subseq str (+ pos size)) (cons (subseq str 0 pos) acc))
        (nreverse (cons str acc)))))

(defmacro minf (field &rest x)
  `(setf ,field (min ,field ,@x)))

(defmacro maxf (field &rest x)
  `(setf ,field (max ,field ,@x)))

(defun solve (stairs n)
  (let ((dp (make-array n :element-type 'integer :initial-element inf)))
    (setf (aref dp 0) 0)
    (dotimes (i (1- n))
      (minf (aref dp (1+ i)) (+ (aref dp i) (abs (- (aref stairs i) (aref stairs (1+ i))))))
      (if (< (+ i 2) n)
          (minf (aref dp (+ i 2)) (+ (aref dp i) (abs (- (aref stairs i) (aref stairs (+ i 2))))))))
    (aref dp (1- n))))

(let* ((n (parse-integer (read-line)))
       (stairs (make-array n :adjustable t :fill-pointer 0)))
  (dotimes (i n)
    (vector-push (read-integer *standard-input*) stairs))
  (format t "~A~%" (solve stairs n)))

