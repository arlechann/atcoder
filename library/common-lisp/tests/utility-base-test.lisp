(in-package :cl-user)

(defpackage :utility-base-test
  (:use :cl :rove))
(in-package :utility-base-test)

(deftest memoize-and-lazy
  (let* ((cnt 0)
         (f (utility.base:memoize-lambda (x y)
              (incf cnt)
              (+ x y))))
    (ok (= 3 (funcall f 1 2)))
    (ok (= 3 (funcall f 1 2)))
    (ok (= 1 cnt)))
  (let* ((cnt 0)
         (f (utility.base:array-memoize-lambda ((i 4) (j 4))
              (incf cnt)
              (+ i j))))
    (ok (= 5 (funcall f 2 3)))
    (ok (= 5 (funcall f 2 3)))
    (ok (= 1 cnt)))
  (let* ((cnt 0)
         (p (utility.base:delay (progn (incf cnt) 42))))
    (ok (= 42 (utility.base:force p)))
    (ok (= 42 (utility.base:force p)))
    (ok (= 1 cnt))))

(deftest sequence-helpers
  (ok (= 6 (utility.base:sum #(1 2 3))))
  (let ((v #(3 1 2)))
    (utility.base:sortf v #'<)
    (ok (equal '(1 2 3) (coerce v 'list))))
  (ok (equal '(10 21 32)
             (utility.base:map-with-index 'list
                                          (lambda (i x) (+ (* 10 i) x))
                                          '(10 11 12))))
  (let ((v (vector 0 0 0)))
    (utility.base:map-into-with-index v (lambda (i x) (+ i x)) #(5 6 7))
    (ok (equal '(5 7 9) (coerce v 'list))))
  (let ((v (vector 1 2 3)))
    (utility.base:nmap (lambda (x) (* x 2)) v)
    (ok (equal '(2 4 6) (coerce v 'list))))
  (ok (equal '((a . 2) (b . 3))
             (utility.base:run-length-encode '(a a b b b)))))

(deftest permutation-helpers
  (let ((v (vector 1 2 3)))
    (ok (equal '(1 3 2) (coerce (utility.base:next-permutation v) 'list)))
    (ok (equal '(2 1 3) (coerce (utility.base:next-permutation v) 'list))))
  (let ((acc nil))
    (utility.base:do-permutations (p #(1 2 3))
      (push (coerce p 'list) acc))
    (ok (= 6 (length acc)))
    (ok (member '(1 2 3) acc :test #'equal))
    (ok (member '(3 2 1) acc :test #'equal))))

(deftest list-helpers
  (ok (= 10 (utility.base:ensure-car '(10 20))))
  (ok (= 10 (utility.base:ensure-car 10)))
  (ok (equal '(x) (utility.base:ensure-list 'x)))
  (ok (equal '(y . x) (utility.base:xcons 'x 'y)))
  (ok (equal '(a b c) (utility.base:take '(a b c d) 3)))
  (ok (equal '(d) (utility.base:drop '(a b c d) 3)))
  (ok (utility.base:length= '(1 2 3) 3))
  (ok (utility.base:length< '(1 2) 3))
  (ok (utility.base:length<= '(1 2) 2))
  (ok (utility.base:singlep '(x)))
  (ok (equal '(0 2 4) (utility.base:iota 3 :start 0 :step 2)))
  (ok (equal '(1 2 3 4 5) (utility.base:flatten '(1 (2 (3)) (4 5)))))
  (ok (equal '(a :sep b :sep c) (utility.base:join '(a b c) :sep)))
  (ok (equal '((1 2) (3 4) (5))
             (utility.base:chunks '(1 2 3 4 5) 2 :fractionp t)))
  (ok (equal '((1 2) (3 4))
             (utility.base:chunks '(1 2 3 4 5) 2 :fractionp nil))))

(deftest char-and-string-helpers
  (ok (= 26 (utility.base:count-alphabet)))
  (ok (= 0 (utility.base:lower-to-index #\a)))
  (ok (= 1 (utility.base:upper-to-index #\B)))
  (ok (= 2 (utility.base:char-to-index #\c)))
  (ok (char= #\d (utility.base:index-to-lower 3)))
  (ok (char= #\D (utility.base:index-to-upper 3)))
  (ok (= 7 (utility.base:char-digit #\7)))
  (ok (equal "a,b,c" (utility.base:strjoin '("a" "b" "c") :spacer ",")))
  (ok (equal "abc"
             (utility.base:trim-spaces
              (concatenate 'string (string #\Space) (string #\Tab) "abc"
                           (string #\Newline) (string #\Return)))))
  (ok (= 2 (aref (utility.base:count-chars "abca") 0))))

(deftest io-helpers
  (ok (equal (format nil "Yes~%")
             (with-output-to-string (s)
               (utility.base:print-boolean t s))))
  (ok (equal (format nil "No~%")
             (with-output-to-string (s)
               (utility.base:print-boolean nil s))))
  (ok (equal (format nil "1 2 3~%")
             (with-output-to-string (s)
               (utility.base:print-sequence '(1 2 3) s))))
  (ok (search "1.5" (with-output-to-string (s)
                      (utility.base:print-double 1.5d0 s)))))
